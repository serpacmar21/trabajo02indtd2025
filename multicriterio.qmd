---
title: "Trabajo 2. Teoría de la Decisión."
author: "Sergio Pacheco Márquez"
format:
  html: default
  pdf: default
---
## 1. Introducción del problema 

El trabajo trata sobre el problema de decisión multicriterio de "Seleccionar el deporte más completo para una vida saludable". El objetivo es evaluar 5 alternativas de deportes (Natación, Running, CrossFit, Ciclismo y Yoga) basándose en una jerarquía de 3 criterios principales (Salud Física, Salud Mental y Viabilidad) y sus subcriterios correspondientes.

Para ello, se aplicarán las técnicas, comenzando por el *Proceso Analítico Jerárquico (AHP)*, seguido de *ELECTRE* y *PROMETHEE*. Finalmente, se compararán los resultados y se extraerán conclusiones.

## 2. Proceso Analítico Jerárquico (AHP)

Para el método AHP, se utiliza el paquete ahp de R. Este método requiere la definición de la jerarquía y la comparación por pares de todos los elementos en cada nivel, lo cual se ha definido en el fichero *deportes.ahp*.

### 2.1 Cálculo del Modelo AHP (con librería)

```{r}
# Cargar librerías 
library(ahp)
library(knitr)
library(kableExtra)
```

```{r}
# Cargar y Calcular AHP

# 1. Cargar el modelo desde el fichero
model <- ahp::Load("deportes.ahp")

# 2. Calcular las prioridades
ahp::Calculate(model)

# 3. Analizar los resultados
results_table <- as.data.frame(ahp::AnalyzeTable(model))
results_priority <- as.data.frame(ahp::AnalyzeTable(model, variable = "priority", sort = "orig"))

rownames(results_table) <- results_table[, 1]
rownames(results_priority) <- results_priority[, 1]
```

### 2.2 Diagrama de jerarquía

```{r}
# Mostrar Diagrama 
Visualize(model)
```

### 2.3 Resultados y Análisis AHP

Las tablas generadas por el paquete ahp nos permiten analizar el ranking final, los pesos de cada criterio y, fundamentalmente, la consistencia de nuestros juicios.

```{r}
# Mostrar Tablas de Resultados

# 1. Tabla de Análisis (Resultados Finales AHP)
kbl(results_table, digits = 3, caption = "Resultados Finales AHP: Contribución Total") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")

# 2. Tabla de Prioridades (Alternativas por Criterio)
kbl(results_priority, digits = 3, caption = "Prioridades Locales por Subcriterio") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 2.4 Conclusiones del Método AHP

Estudio de Inconsistencia

Un paso fundamental en AHP es verificar la consistencia de las matrices de comparación 2 a 2. Según la teoría, un ratio de inconsistencia (Inconsistency) superior al 10% (0.10) invalidaría los juicios.

En nuestros resultados, la inconsistencia de la matriz principal es del 3.7%. Todas las demás matrices (ej. 5.8% para Salud Física, 4.0% para Desarrollo Muscular) se encuentran muy por debajo del límite del 10%.

Por tanto, las valoraciones han sido coherentes y los resultados del método AHP son robustos y fiables.

Comentarios al Ranking

El ranking final obtenido mediante AHP es el siguiente:

1.Yoga (24.1%)

2.CrossFit (23.7%)

3.Natación (20.2%)

4.Running (17.3%)

5.Ciclismo (14.7%)

Análisis de la tabla:

- El Yoga obtiene el primer puesto gracias a su dominio absoluto en los criterios de Salud Mental, aportando un 10.9% del peso total solo desde Reducción de Estrés.

- El CrossFit queda en un segundo lugar muy cercano. Su puntuación se debe casi en su totalidad a su gran superioridad en Desarrollo Muscular (contribuye un 14.0% del total).

- La Natación es la alternativa más equilibrada, con buenas puntuaciones en Salud Cardiovascular (6.7%) y, especialmente, en Bajo Impacto Articular (3.9%), pero no logra dominar en los criterios de mayor peso.

- El Running y el Ciclismo quedan en las últimas posiciones, penalizados por factores como el alto impacto (Running) o la menor puntuación en Flexibilidad y Reducción de Estrés.

## 3. Método AHP (con R)

En este apartado, se replica el análisis AHP utilizando las funciones R proporcionadas.

### 3.1. Nivel 1: Criterios Principales

Primero, definimos la matriz de comparación 2 a 2 para los 3 criterios principales.

```{r}

# --- Cargar Funciones
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_utiles.R")
source("teoriadecision_funciones_multicriterio_diagram.R")


# 1. Crear la matriz de Criterios Principales
# Usamos los mismos valores que en el fichero .ahp
# [Salud Fisica (3) vs Salud Mental], [Salud Fisica (5) vs Viabilidad], [Salud Mental (3) vs Viabilidad]
mat_c1 <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(3, 5, 3), 
  numalternativas = 3,
  v.nombres.alternativas = c("Salud Fisica", "Salud Mental", "Viabilidad")
)

# 2. Calcular los pesos locales
pesos_c1_R <- multicriterio.metodoAHP.variante3.basico(mat_c1)$valoraciones.ahp

# 3. Calcular la Inconsistencia (Requisito de la evaluación)
incons_c1_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c1)

print("--- Matriz Criterios Principales (AHP-R) ---")
kbl(mat_c1, digits = 3, caption = "Matriz Criterios Principales (AHP-R)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")

print("--- Pesos Criterios Principales (AHP-R) ---")
kbl(t(pesos_c1_R), digits = 4, caption = "Pesos Locales Criterios Principales") %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print(paste("Ratio de Inconsistencia (C1):", round(incons_c1_R$RI.coef.inconsistencia, 4)))
```

### 3.2. Nivel 2: Subcriterios

Ahora, definimos las matrices de comparación para los subcriterios que dependen de cada criterio principal.

```{r}
# 1. Matriz de Subcriterios de C1: Salud Física
# [Cardio (1) vs Músculo], [Cardio (3) vs Flexibilidad], [Cardio (3) vs Impacto]
# [Músculo (3) vs Flexibilidad], [Músculo (3) vs Impacto]
# [Flexibilidad (1/3) vs Impacto]
mat_c1_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(1, 3, 3, 3, 3, 1/3),
  numalternativas = 4,
  v.nombres.alternativas = c("Salud Cardiovascular", "Desarrollo Muscular", 
                             "Flexibilidad y Movilidad", "Bajo Impacto Articular")
)
pesos_c1_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c1_sub)$valoraciones.ahp
incons_c1_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c1_sub)

print(paste("Ratio de Inconsistencia (C1-Sub):", round(incons_c1_sub_R$RI.coef.inconsistencia, 4)))


# 2. Matriz de Subcriterios de C2: Salud Mental
# [Estrés (3) vs Social]
mat_c2_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(3),
  numalternativas = 2,
  v.nombres.alternativas = c("Reducción Estres", "Componente Social")
)
pesos_c2_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c2_sub)$valoraciones.ahp
incons_c2_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c2_sub)

print(paste("Ratio de Inconsistencia (C2-Sub):", round(incons_c2_sub_R$RI.coef.inconsistencia, 4)))


# 3. Matriz de Subcriterios de C3: Viabilidad
# [Coste (1/3) vs Accesibilidad]
mat_c3_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(1/3),
  numalternativas = 2,
  v.nombres.alternativas = c("Coste Economico", "Accesibilidad")
)
pesos_c3_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c3_sub)$valoraciones.ahp
incons_c3_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c3_sub)

print(paste("Ratio de Inconsistencia (C3-Sub):", round(incons_c3_sub_R$RI.coef.inconsistencia, 4)))

# Mostramos las tablas de pesos (las matrices son muy grandes para el PDF)
print("--- Pesos Subcriterios de Salud Física (AHP-R) ---")
kbl(t(pesos_c1_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print("--- Pesos Subcriterios de Salud Mental (AHP-R) ---")
kbl(t(pesos_c2_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print("--- Pesos Subcriterios de Viabilidad (AHP-R) ---")
kbl(t(pesos_c3_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")
```

### 3.3. Nivel 3: Alternativas

Finalmente, se crean las 8 matrices de comparación para las 5 alternativas, una por cada subcriterio. Para cada matriz, se calculan los pesos locales y el ratio de inconsistencia.

```{r}
# Definimos los nombres de las alternativas
v_nombres_alt <- c("Natacion", "Running", "CrossFit", "Ciclismo", "Yoga")
num_alt <- 5
lista_pesos_locales <- list() # Aquí guardaremos los 8 vectores de pesos
lista_inconsistencia <- list() # Aquí guardaremos los 8 ratios

# 1. Matriz para C1.1: Salud Cardiovascular
mat_alt_1_cardio <- multicriterio.crea.matrizvaloraciones_mej(
  c(1, 3, 1, 7, 3, 1, 7, 1/3, 5, 7), num_alt, v_nombres_alt)
pesos_alt_1_cardio_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_1_cardio)$valoraciones.ahp
lista_pesos_locales[["Cardio"]] <- pesos_alt_1_cardio_R
lista_inconsistencia[["Cardio"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_1_cardio)$RI.coef.inconsistencia

# 2. Matriz para C1.2: Desarrollo Muscular
mat_alt_2_musculo <- multicriterio.crea.matrizvaloraciones_mej(
  c(3, 1/5, 3, 5, 1/7, 1, 3, 7, 9, 3), num_alt, v_nombres_alt)
pesos_alt_2_musculo_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_2_musculo)$valoraciones.ahp
lista_pesos_locales[["Musculo"]] <- pesos_alt_2_musculo_R
lista_inconsistencia[["Musculo"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_2_musculo)$RI.coef.inconsistencia

# 3. Matriz para C1.3: Flexibilidad y Movilidad
mat_alt_3_flexibilidad <- multicriterio.crea.matrizvaloraciones_mej(
  c(3, 1, 3, 1/5, 1/3, 1, 1/7, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_3_flexibilidad_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_3_flexibilidad)$valoraciones.ahp
lista_pesos_locales[["Flexibilidad"]] <- pesos_alt_3_flexibilidad_R
lista_inconsistencia[["Flexibilidad"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_3_flexibilidad)$RI.coef.inconsistencia

# 4. Matriz para C1.4: Bajo Impacto Articular
mat_alt_4_impacto <- multicriterio.crea.matrizvaloraciones_mej(
  c(7, 5, 3, 1, 1/3, 1/5, 1/7, 1/3, 1/5, 1/3), num_alt, v_nombres_alt)
pesos_alt_4_impacto_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_4_impacto)$valoraciones.ahp
lista_pesos_locales[["Impacto"]] <- pesos_alt_4_impacto_R
lista_inconsistencia[["Impacto"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_4_impacto)$RI.coef.inconsistencia

# 5. Matriz para C2.1: Reducción Estres
mat_alt_5_estres <- multicriterio.crea.matrizvaloraciones_mej(
  c(1, 5, 1, 1/5, 5, 1, 1/5, 1/5, 1/9, 1/5), num_alt, v_nombres_alt)
pesos_alt_5_estres_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_5_estres)$valoraciones.ahp
lista_pesos_locales[["Estres"]] <- pesos_alt_5_estres_R
lista_inconsistencia[["Estres"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_5_estres)$RI.coef.inconsistencia

# 6. Matriz para C2.2: Componente Social
mat_alt_6_social <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/3, 1/7, 1/3, 1, 1/5, 1, 3, 5, 7, 3), num_alt, v_nombres_alt)
pesos_alt_6_social_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_6_social)$valoraciones.ahp
lista_pesos_locales[["Social"]] <- pesos_alt_6_social_R
lista_inconsistencia[["Social"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_6_social)$RI.coef.inconsistencia

# 7. Matriz para C3.1: Coste Economico
mat_alt_7_coste <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/3, 3, 5, 1, 7, 9, 3, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_7_coste_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_7_coste)$valoraciones.ahp
lista_pesos_locales[["Coste"]] <- pesos_alt_7_coste_R
lista_inconsistencia[["Coste"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_7_coste)$RI.coef.inconsistencia

# 8. Matriz para C3.2: Accesibilidad
mat_alt_8_accesibilidad <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/5, 1, 3, 1/5, 5, 7, 1, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_8_accesibilidad_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_8_accesibilidad)$valoraciones.ahp
lista_pesos_locales[["Accesibilidad"]] <- pesos_alt_8_accesibilidad_R
lista_inconsistencia[["Accesibilidad"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_8_accesibilidad)$RI.coef.inconsistencia

# Imprimir solo el estudio de inconsistencia (para no saturar el informe)
print("--- Estudio de Inconsistencia (AHP-R Nivel Alternativas) ---")
inconsistencia_df <- data.frame(Ratio_Inconsistencia = unlist(lista_inconsistencia))

kbl(inconsistencia_df, digits = 4, caption = "Inconsistencia de las 8 Matrices de Alternativas") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 3.4. Cálculo del Ranking Global (AHP-R)

Finalmente, se calcula el ranking global. Para ello, primero se calcula el peso global de cada uno de los 8 subcriterios (hojas del árbol) multiplicando el peso de su criterio principal por su peso local.

```{r}

# 1. Calcular el vector de pesos globales de los 8 subcriterios
# (Peso Criterio * Peso Local Subcriterio)
vec_pesos_globales_sub_R <- c(
  pesos_c1_R[1] * pesos_c1_sub_R,  # Pesos de C1 * Sub-pesos de C1
  pesos_c1_R[2] * pesos_c2_sub_R,  # Pesos de C1 * Sub-pesos de C2
  pesos_c1_R[3] * pesos_c3_sub_R   # Pesos de C1 * Sub-pesos de C3
)

# 2. Crear la matriz de pesos de alternativas (8 Subcriterios x 5 Alternativas)
# Usamos 'do.call(rbind, ...)' para unir los 8 vectores de la lista
mat_alt_final_R <- do.call(rbind, lista_pesos_locales)

# 3. Calcular el ranking final (Producto matricial)
# (1x8) %*% (8x5) = (1x5)
# Esto es: (Pesos Globales Subcriterios) %*% (Pesos Locales Alternativas)
ranking_final_R <- vec_pesos_globales_sub_R %*% mat_alt_final_R

# 4. Formatear y mostrar la tabla de resultados
ranking_df_R <- as.data.frame(t(ranking_final_R)) # Transponer para ver en columna
colnames(ranking_df_R) <- "Ponderacion_Global_AHP_R"
ranking_df_R <- ranking_df_R[order(ranking_df_R$Ponderacion_Global_AHP_R, decreasing = TRUE), , drop = FALSE]

print("--- Ranking Final (AHP-R) ---")
kbl(ranking_df_R, digits = 4, caption = "Ranking Final (AHP con Funciones R)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 3.5. Conclusiones del Método AHP (con R)

El análisis manual con las funciones R de la asignatura (AHPconR) cumple dos objetivos:

-Estudio de Inconsistencia: Como se vio en los chunks anteriores, se ha calculado el Ratio de Inconsistencia (RI) para cada una de las 12 matrices de comparación. Todos los valores (ej. 0.0055 para la matriz de criterios) están muy por debajo del límite del 10%, validando la coherencia de los juicios.

-Ranking Final: El ranking obtenido (ver Tabla "Ranking Final (AHP con Funciones R)") es idéntico al obtenido con el paquete ahp (Tabla "Resultados Finales AHP").

*Conclusión*: Ambos métodos de AHP (Paquete y Funciones R) producen el mismo resultado, lo que confirma la correcta aplicación de ambas técnicas.

## 4. Método ELECTRE

El método ELECTRE es un enfoque basado en la comparación por pares de alternativas, utilizando los conceptos de concordancia y discordancia para establecer relaciones de dominancia.

### 4.1 Carga de Funciones y Preparación de Datos

Para mantener la consistencia del análisis, se utilizan los resultados del método AHP como datos de entrada.

```{r}
# Cargar funciones

source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_utiles.R")

# Preparar datos

# 1. Seleccionar solo los 8 subcriterios
nombres_subcriterios <- c("Salud Cardiovascular", "Desarrollo Muscular", 
                        "Flexibilidad y Movilidad", "Bajo Impacto Articular",
                        "Reduccion Estres", "Componente Social",
                        "Coste Economico", "Accesibilidad")

# 2. Usar la tabla de prioridad local de AHP (results_priority)
matriz_base <- results_priority[nombres_subcriterios, 
                              c("Natacion", "Running", "CrossFit", "Ciclismo", "Yoga")]
```

### 4.2 Creación de la Matriz de Decisión

A partir de los datos de AHP, se construye la matriz de decisión que requiere ELECTRE.

```{r}

# Crear Matriz de Decisión

# 1. Transponer la matriz para tener (Alternativas x Criterios)
matriz_electre <- t(matriz_base)

# 2. Mostrar la matriz de decisión que usaremos
kbl(matriz_electre, digits = 3, caption = "Matriz de Decisión para ELECTRE") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 4.3 Definición de Pesos y Parámetros

```{r}
# 1. Preparar Pesos 
# Extraer pesos globales de la Tabla 1 de AHP
pesos_globales_ahp <- results_table[nombres_subcriterios, "Weight"]

# Normalizar los pesos para que sumen 1 (requisito de la función)
pesos_electre <- pesos_globales_ahp / sum(pesos_globales_ahp)

print("--- Pesos Normalizados para ELECTRE ---")
# Usamos kbl para mostrar el vector de pesos de forma ordenada
kbl(t(pesos_electre), digits = 3, caption = "Vector de Pesos (W) para ELECTRE") %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

# 2. Preparar Parámetros
# Nivel de Concordancia
alpha_concordancia <- 0.7 

# Umbrales de Discordancia (d_i)
# Una diferencia mayor a 0.10 (10%) en los criterios más importantes
# (Músculo y Estrés) es inaceptable. El resto se pueden compensar (Inf).
umbrales_discordancia <- c(
    Inf,    # C1.1 Cardio
    0.10,   # C1.2 Músculo (Muy Importante)
    Inf,    # C1.3 Flexibilidad
    Inf,    # C1.4 Impacto
    0.10,   # C2.1 Estrés (Muy Importante)
    Inf,    # C2.2 Social
    Inf,    # C3.1 Coste
    Inf     # C3.2 Accesibilidad
)
```

### 4.4 Ejecución y Análisis Iterativo

Realizamos un análisis iterativo para encontrar el núcleo del grafo de superación.

#### Iteración 1: Todas las alternativas

Primero, ejecutamos el método con las 5 alternativas.

```{r}
#Ejecutar ELECTRE I (Iteración 1) 

print("--- Ejecutando ELECTRE I: Iteración 1 (Todas las alternativas) ---")

# 1. Ejecutar ELECTRE I (Iteración 1: Todas las alternativas)
#    Usamos la función de clase
salida_electre1 <- multicriterio.metodoELECTRE_I(
    tabdecs.X = matriz_electre,
    pesos.criterios = pesos_electre,
    nivel.concordancia.minimo.alpha = alpha_concordancia,
    no.se.compensan = umbrales_discordancia
)

# 2. Mostrar el núcleo (las mejores alternativas)
print("--- ELECTRE Iteración 1: Núcleo Aproximado ---")
print(salida_electre1$nucleo_aprox)

# 3. Mostrar el grafo de dominancia
print("--- ELECTRE Iteración 1: Grafo de Dominancia ---")
qgraph::qgraph(salida_electre1$relacion.dominante, 
               labels = rownames(matriz_electre),
               edge.labels = FALSE,
               posCol = "blue",
               label.cex = 1.2,
               label.color = "black",
               vsize = 10)
```

#### Iteración 2: Filtrado del Núcleo

El núcleo de la Iteración 1 nos devuelve 4 alternativas. Repetimos el análisis solo con estas alternativas para intentar desempatar.

```{r}
# Ejecutar ELECTRE I (Iteración 2)

# 1. Identificamos las alternativas del núcleo anterior
alternativas_nucleo1 <- salida_electre1$nucleo_aprox 
alternativas_nucleo1_nombres <- names(alternativas_nucleo1)

print("--- Ejecutando ELECTRE I: Iteración 2 (solo núcleo) ---")
print("Alternativas en esta iteración:")
print(alternativas_nucleo1_nombres)

# 2. Ejecutamos ELECTRE I de nuevo, pero pasando el vector de
#    alternativas en el parámetro 'que.alternativas'
salida_electre2 <- multicriterio.metodoELECTRE_I(
    tabdecs.X = matriz_electre,
    pesos.criterios = pesos_electre,
    nivel.concordancia.minimo.alpha = alpha_concordancia,
    no.se.compensan = umbrales_discordancia,
    que.alternativas = alternativas_nucleo1_nombres # ¡Filtro clave!
)

# 3. Imprimir el núcleo final
print("--- ELECTRE Iteración 2: Núcleo Final ---")
print(salida_electre2$nucleo_aprox)

# 4. Mostrar el grafo de dominancia final
print("--- ELECTRE Iteración 2: Grafo de Dominancia Final ---")
qgraph::qgraph(salida_electre2$relacion.dominante, 
               labels = alternativas_nucleo1_nombres,
               edge.labels = FALSE,
               posCol = "blue",
               label.cex = 1.2,
               label.color = "black",
               vsize = 10)
```


### 4.5 Conclusiones del Método ELECTRE I

El método ELECTRE I se ha ejecutado **siguiendo el paso a paso** requerido.

1.  **Iteración 1:** Al ejecutar el método con las 5 alternativas, el grafo de superación mostró que la alternativa "Ciclismo" era dominada, mientras que las otras cuatro (Natacion, Running, CrossFit, Yoga) no recibían ninguna relación de dominancia. El **núcleo aproximado** resultante fue, por tanto, **[Natacion, Running, CrossFit, Yoga]**.

2.  **Iteración 2:** Para desempatar, se repite el análisis filtrando solo por las alternativas del núcleo. El grafo resultante **no muestra ninguna flecha**, lo que significa que existe una **relación de incomparabilidad** entre estas cuatro alternativas. El núcleo final sigue siendo **[Natacion, Running, CrossFit, Yoga]**.

**Conclusión:** ELECTRE I no nos da un único ganador. Concluye que **Natación, Running, CrossFit y Yoga** son las mejores opciones y son **incomparables** entre sí; ninguna es estrictamente mejor que la otra bajo los parámetros $\alpha=0.7$ y los umbrales de discordancia establecidos.