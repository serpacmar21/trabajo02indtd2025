---
title: "Trabajo 2. Teoría de la Decisión."
author: "Sergio Pacheco Márquez"
format:
  html: default
  pdf: default
---
## 1. Introducción del problema 

El trabajo trata sobre el problema de decisión multicriterio de "Seleccionar el deporte más completo para una vida saludable". El objetivo es evaluar 5 alternativas de deportes (Natación, Running, CrossFit, Ciclismo y Yoga) basándose en una jerarquía de 3 criterios principales (Salud Física, Salud Mental y Viabilidad) y sus subcriterios correspondientes.

Para ello, se aplicarán las técnicas, comenzando por el *Proceso Analítico Jerárquico (AHP)*, seguido de *ELECTRE* y *PROMETHEE*. Finalmente, se compararán los resultados y se extraerán conclusiones.

## 2. Proceso Analítico Jerárquico (AHP)

Para el método AHP, se utiliza el paquete ahp de R. Este método requiere la definición de la jerarquía y la comparación por pares de todos los elementos en cada nivel, lo cual se ha definido en el fichero *deportes.ahp*.

### 2.1 Cálculo del Modelo AHP (con librería)

```{r}
# Cargar librerías 
library(ahp)
library(knitr)
library(kableExtra)
```

```{r}
# Cargar y Calcular AHP

# 1. Cargar el modelo desde el fichero
model <- ahp::Load("deportes.ahp")

# 2. Calcular las prioridades
ahp::Calculate(model)

# 3. Analizar los resultados
results_table <- as.data.frame(ahp::AnalyzeTable(model))
results_priority <- as.data.frame(ahp::AnalyzeTable(model, variable = "priority", sort = "orig"))

rownames(results_table) <- results_table[, 1]
rownames(results_priority) <- results_priority[, 1]
```

### 2.2 Diagrama de jerarquía

```{r}
# Mostrar Diagrama 
Visualize(model)
```

### 2.3 Resultados y Análisis AHP

Las tablas generadas por el paquete ahp nos permiten analizar el ranking final, los pesos de cada criterio y, fundamentalmente, la consistencia de nuestros juicios.

```{r}
# Mostrar Tablas de Resultados

# 1. Tabla de Análisis (Resultados Finales AHP)
kbl(results_table, digits = 3, caption = "Resultados Finales AHP: Contribución Total") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")

# 2. Tabla de Prioridades (Alternativas por Criterio)
kbl(results_priority, digits = 3, caption = "Prioridades Locales por Subcriterio") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 2.4 Conclusiones del Método AHP

Estudio de Inconsistencia

Un paso fundamental en AHP es verificar la consistencia de las matrices de comparación 2 a 2. Según la teoría, un ratio de inconsistencia (Inconsistency) superior al 10% (0.10) invalidaría los juicios.

En nuestros resultados, la inconsistencia de la matriz principal es del 3.7%. Todas las demás matrices (ej. 5.8% para Salud Física, 4.0% para Desarrollo Muscular) se encuentran muy por debajo del límite del 10%.

Por tanto, las valoraciones han sido coherentes y los resultados del método AHP son robustos y fiables.

Comentarios al Ranking

El ranking final obtenido mediante AHP es el siguiente:

1.Yoga (24.1%)

2.CrossFit (23.7%)

3.Natación (20.2%)

4.Running (17.3%)

5.Ciclismo (14.7%)

Análisis de la tabla:

- El Yoga obtiene el primer puesto gracias a su dominio absoluto en los criterios de Salud Mental, aportando un 10.9% del peso total solo desde Reducción de Estrés.

- El CrossFit queda en un segundo lugar muy cercano. Su puntuación se debe casi en su totalidad a su gran superioridad en Desarrollo Muscular (contribuye un 14.0% del total).

- La Natación es la alternativa más equilibrada, con buenas puntuaciones en Salud Cardiovascular (6.7%) y, especialmente, en Bajo Impacto Articular (3.9%), pero no logra dominar en los criterios de mayor peso.

- El Running y el Ciclismo quedan en las últimas posiciones, penalizados por factores como el alto impacto (Running) o la menor puntuación en Flexibilidad y Reducción de Estrés.

## 3. Método AHP (con R)

En este apartado, se replica el análisis AHP utilizando las funciones R proporcionadas.

### 3.1. Nivel 1: Criterios Principales

Primero, definimos la matriz de comparación 2 a 2 para los 3 criterios principales.

```{r}

# --- Cargar Funciones
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_utiles.R")
source("teoriadecision_funciones_multicriterio_diagram.R")


# 1. Crear la matriz de Criterios Principales
# Usamos los mismos valores que en el fichero .ahp
# [Salud Fisica (3) vs Salud Mental], [Salud Fisica (5) vs Viabilidad], [Salud Mental (3) vs Viabilidad]
mat_c1 <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(3, 5, 3), 
  numalternativas = 3,
  v.nombres.alternativas = c("Salud Fisica", "Salud Mental", "Viabilidad")
)

# 2. Calcular los pesos locales
pesos_c1_R <- multicriterio.metodoAHP.variante3.basico(mat_c1)$valoraciones.ahp

# 3. Calcular la Inconsistencia (Requisito de la evaluación)
incons_c1_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c1)

print("--- Matriz Criterios Principales (AHP-R) ---")
kbl(mat_c1, digits = 3, caption = "Matriz Criterios Principales (AHP-R)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")

print("--- Pesos Criterios Principales (AHP-R) ---")
kbl(t(pesos_c1_R), digits = 4, caption = "Pesos Locales Criterios Principales") %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print(paste("Ratio de Inconsistencia (C1):", round(incons_c1_R$RI.coef.inconsistencia, 4)))
```

### 3.2. Nivel 2: Subcriterios

Ahora, definimos las matrices de comparación para los subcriterios que dependen de cada criterio principal.

```{r}
# 1. Matriz de Subcriterios de C1: Salud Física
# [Cardio (1) vs Músculo], [Cardio (3) vs Flexibilidad], [Cardio (3) vs Impacto]
# [Músculo (3) vs Flexibilidad], [Músculo (3) vs Impacto]
# [Flexibilidad (1/3) vs Impacto]
mat_c1_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(1, 3, 3, 3, 3, 1/3),
  numalternativas = 4,
  v.nombres.alternativas = c("Salud Cardiovascular", "Desarrollo Muscular", 
                             "Flexibilidad y Movilidad", "Bajo Impacto Articular")
)
pesos_c1_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c1_sub)$valoraciones.ahp
incons_c1_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c1_sub)

print(paste("Ratio de Inconsistencia (C1-Sub):", round(incons_c1_sub_R$RI.coef.inconsistencia, 4)))


# 2. Matriz de Subcriterios de C2: Salud Mental
# [Estrés (3) vs Social]
mat_c2_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(3),
  numalternativas = 2,
  v.nombres.alternativas = c("Reduccion Estres", "Componente Social")
)
pesos_c2_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c2_sub)$valoraciones.ahp
incons_c2_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c2_sub)

print(paste("Ratio de Inconsistencia (C2-Sub):", round(incons_c2_sub_R$RI.coef.inconsistencia, 4)))


# 3. Matriz de Subcriterios de C3: Viabilidad
# [Coste (1/3) vs Accesibilidad]
mat_c3_sub <- multicriterio.crea.matrizvaloraciones_mej(
  vector_valoraciones_diagsup = c(1/3),
  numalternativas = 2,
  v.nombres.alternativas = c("Coste Economico", "Accesibilidad")
)
pesos_c3_sub_R <- multicriterio.metodoAHP.variante3.basico(mat_c3_sub)$valoraciones.ahp
incons_c3_sub_R <- multicriterio.metodoAHP.coef.inconsistencia(mat_c3_sub)

print(paste("Ratio de Inconsistencia (C3-Sub):", round(incons_c3_sub_R$RI.coef.inconsistencia, 4)))

# Mostramos las tablas de pesos (las matrices son muy grandes para el PDF)
print("--- Pesos Subcriterios de Salud Física (AHP-R) ---")
kbl(t(pesos_c1_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print("--- Pesos Subcriterios de Salud Mental (AHP-R) ---")
kbl(t(pesos_c2_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

print("--- Pesos Subcriterios de Viabilidad (AHP-R) ---")
kbl(t(pesos_c3_sub_R), digits = 4) %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")
```

### 3.3. Nivel 3: Alternativas

Finalmente, se crean las 8 matrices de comparación para las 5 alternativas, una por cada subcriterio. Para cada matriz, se calculan los pesos locales y el ratio de inconsistencia.

```{r}
# Definimos los nombres de las alternativas
v_nombres_alt <- c("Natacion", "Running", "CrossFit", "Ciclismo", "Yoga")
num_alt <- 5
lista_pesos_locales <- list() # Aquí guardaremos los 8 vectores de pesos
lista_inconsistencia <- list() # Aquí guardaremos los 8 ratios

# 1. Matriz para C1.1: Salud Cardiovascular
mat_alt_1_cardio <- multicriterio.crea.matrizvaloraciones_mej(
  c(1, 3, 1, 7, 3, 1, 7, 1/3, 5, 7), num_alt, v_nombres_alt)
pesos_alt_1_cardio_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_1_cardio)$valoraciones.ahp
lista_pesos_locales[["Cardio"]] <- pesos_alt_1_cardio_R
lista_inconsistencia[["Cardio"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_1_cardio)$RI.coef.inconsistencia

# 2. Matriz para C1.2: Desarrollo Muscular
mat_alt_2_musculo <- multicriterio.crea.matrizvaloraciones_mej(
  c(3, 1/5, 3, 5, 1/7, 1, 3, 7, 9, 3), num_alt, v_nombres_alt)
pesos_alt_2_musculo_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_2_musculo)$valoraciones.ahp
lista_pesos_locales[["Musculo"]] <- pesos_alt_2_musculo_R
lista_inconsistencia[["Musculo"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_2_musculo)$RI.coef.inconsistencia

# 3. Matriz para C1.3: Flexibilidad y Movilidad
mat_alt_3_flexibilidad <- multicriterio.crea.matrizvaloraciones_mej(
  c(3, 1, 3, 1/5, 1/3, 1, 1/7, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_3_flexibilidad_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_3_flexibilidad)$valoraciones.ahp
lista_pesos_locales[["Flexibilidad"]] <- pesos_alt_3_flexibilidad_R
lista_inconsistencia[["Flexibilidad"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_3_flexibilidad)$RI.coef.inconsistencia

# 4. Matriz para C1.4: Bajo Impacto Articular
mat_alt_4_impacto <- multicriterio.crea.matrizvaloraciones_mej(
  c(7, 5, 3, 1, 1/3, 1/5, 1/7, 1/3, 1/5, 1/3), num_alt, v_nombres_alt)
pesos_alt_4_impacto_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_4_impacto)$valoraciones.ahp
lista_pesos_locales[["Impacto"]] <- pesos_alt_4_impacto_R
lista_inconsistencia[["Impacto"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_4_impacto)$RI.coef.inconsistencia

# 5. Matriz para C2.1: Reducción Estres
mat_alt_5_estres <- multicriterio.crea.matrizvaloraciones_mej(
  c(1, 5, 1, 1/5, 5, 1, 1/5, 1/5, 1/9, 1/5), num_alt, v_nombres_alt)
pesos_alt_5_estres_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_5_estres)$valoraciones.ahp
lista_pesos_locales[["Estres"]] <- pesos_alt_5_estres_R
lista_inconsistencia[["Estres"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_5_estres)$RI.coef.inconsistencia

# 6. Matriz para C2.2: Componente Social
mat_alt_6_social <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/3, 1/7, 1/3, 1, 1/5, 1, 3, 5, 7, 3), num_alt, v_nombres_alt)
pesos_alt_6_social_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_6_social)$valoraciones.ahp
lista_pesos_locales[["Social"]] <- pesos_alt_6_social_R
lista_inconsistencia[["Social"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_6_social)$RI.coef.inconsistencia

# 7. Matriz para C3.1: Coste Economico
mat_alt_7_coste <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/3, 3, 5, 1, 7, 9, 3, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_7_coste_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_7_coste)$valoraciones.ahp
lista_pesos_locales[["Coste"]] <- pesos_alt_7_coste_R
lista_inconsistencia[["Coste"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_7_coste)$RI.coef.inconsistencia

# 8. Matriz para C3.2: Accesibilidad
mat_alt_8_accesibilidad <- multicriterio.crea.matrizvaloraciones_mej(
  c(1/5, 1, 3, 1/5, 5, 7, 1, 3, 1/5, 1/7), num_alt, v_nombres_alt)
pesos_alt_8_accesibilidad_R <- multicriterio.metodoAHP.variante3.basico(mat_alt_8_accesibilidad)$valoraciones.ahp
lista_pesos_locales[["Accesibilidad"]] <- pesos_alt_8_accesibilidad_R
lista_inconsistencia[["Accesibilidad"]] <- multicriterio.metodoAHP.coef.inconsistencia(mat_alt_8_accesibilidad)$RI.coef.inconsistencia

# Imprimir solo el estudio de inconsistencia (para no saturar el informe)
print("--- Estudio de Inconsistencia (AHP-R Nivel Alternativas) ---")
inconsistencia_df <- data.frame(Ratio_Inconsistencia = unlist(lista_inconsistencia))

kbl(inconsistencia_df, digits = 4, caption = "Inconsistencia de las 8 Matrices de Alternativas") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 3.4. Cálculo del Ranking Global (AHP-R)

Finalmente, se calcula el ranking global. Para ello, primero se calcula el peso global de cada uno de los 8 subcriterios (hojas del árbol) multiplicando el peso de su criterio principal por su peso local.

```{r}

# 1. Calcular el vector de pesos globales de los 8 subcriterios
# (Peso Criterio * Peso Local Subcriterio)
vec_pesos_globales_sub_R <- c(
  pesos_c1_R[1] * pesos_c1_sub_R,  # Pesos de C1 * Sub-pesos de C1
  pesos_c1_R[2] * pesos_c2_sub_R,  # Pesos de C1 * Sub-pesos de C2
  pesos_c1_R[3] * pesos_c3_sub_R   # Pesos de C1 * Sub-pesos de C3
)

# 2. Crear la matriz de pesos de alternativas (8 Subcriterios x 5 Alternativas)
# Usamos 'do.call(rbind, ...)' para unir los 8 vectores de la lista
mat_alt_final_R <- do.call(rbind, lista_pesos_locales)

# 3. Calcular el ranking final (Producto matricial)
# (1x8) %*% (8x5) = (1x5)
# Esto es: (Pesos Globales Subcriterios) %*% (Pesos Locales Alternativas)
ranking_final_R <- vec_pesos_globales_sub_R %*% mat_alt_final_R

# 4. Formatear y mostrar la tabla de resultados
ranking_df_R <- as.data.frame(t(ranking_final_R)) # Transponer para ver en columna
colnames(ranking_df_R) <- "Ponderacion_Global_AHP_R"
ranking_df_R <- ranking_df_R[order(ranking_df_R$Ponderacion_Global_AHP_R, decreasing = TRUE), , drop = FALSE]

print("--- Ranking Final (AHP-R) ---")
kbl(ranking_df_R, digits = 4, caption = "Ranking Final (AHP con Funciones R)") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 3.5. Conclusiones del Método AHP (con R)

El análisis manual con las funciones R de la asignatura (AHPconR) cumple dos objetivos:

-Estudio de Inconsistencia: Como se vio en los chunks anteriores, se ha calculado el Ratio de Inconsistencia (RI) para cada una de las 12 matrices de comparación. Todos los valores (ej. 0.0055 para la matriz de criterios) están muy por debajo del límite del 10%, validando la coherencia de los juicios.

-Ranking Final: El ranking obtenido (ver Tabla "Ranking Final (AHP con Funciones R)") es idéntico al obtenido con el paquete ahp (Tabla "Resultados Finales AHP").

*Conclusión*: Ambos métodos de AHP (Paquete y Funciones R) producen el mismo resultado, lo que confirma la correcta aplicación de ambas técnicas.

## 4. Método ELECTRE

El método ELECTRE es un enfoque basado en la comparación por pares de alternativas, utilizando los conceptos de concordancia y discordancia para establecer relaciones de dominancia.

### 4.1 Carga de Funciones y Preparación de Datos

Para mantener la consistencia del análisis, se utilizan los resultados del método AHP como datos de entrada.

```{r}
# Cargar funciones

source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_utiles.R")

# Preparar datos

# 1. Seleccionar solo los 8 subcriterios
nombres_subcriterios <- c("Salud Cardiovascular", "Desarrollo Muscular", 
                        "Flexibilidad y Movilidad", "Bajo Impacto Articular",
                        "Reduccion Estres", "Componente Social",
                        "Coste Economico", "Accesibilidad")

# 2. Usar la tabla de prioridad local de AHP (results_priority)
matriz_base <- results_priority[nombres_subcriterios, 
                              c("Natacion", "Running", "CrossFit", "Ciclismo", "Yoga")]
```

### 4.2 Creación de la Matriz de Decisión

A partir de los datos de AHP, se construye la matriz de decisión que requiere ELECTRE.

```{r}

# Crear Matriz de Decisión

# 1. Transponer la matriz para tener (Alternativas x Criterios)
matriz_electre <- t(matriz_base)

# 2. Mostrar la matriz de decisión que usaremos
kbl(matriz_electre, digits = 3, caption = "Matriz de Decisión para ELECTRE") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "center")
```

### 4.3 Definición de Pesos y Parámetros

```{r}
# 1. Preparar Pesos 
# Extraer pesos globales de la Tabla 1 de AHP
pesos_globales_ahp <- results_table[nombres_subcriterios, "Weight"]

# Normalizar los pesos para que sumen 1 (requisito de la función)
pesos_electre <- pesos_globales_ahp / sum(pesos_globales_ahp)

print("--- Pesos Normalizados para ELECTRE ---")
# Usamos kbl para mostrar el vector de pesos de forma ordenada
kbl(t(pesos_electre), digits = 3, caption = "Vector de Pesos (W) para ELECTRE") %>%
  kable_styling(bootstrap_options = "striped", full_width = T, position = "center")

# 2. Preparar Parámetros
# Nivel de Concordancia
alpha_concordancia <- 0.7 

# Umbrales de Discordancia (d_i)
# Una diferencia mayor a 0.10 (10%) en los criterios más importantes
# (Músculo y Estrés) es inaceptable. El resto se pueden compensar (Inf).
umbrales_discordancia <- c(
    Inf,    # C1.1 Cardio
    0.10,   # C1.2 Músculo (Muy Importante)
    Inf,    # C1.3 Flexibilidad
    Inf,    # C1.4 Impacto
    0.10,   # C2.1 Estrés (Muy Importante)
    Inf,    # C2.2 Social
    Inf,    # C3.1 Coste
    Inf     # C3.2 Accesibilidad
)
```

### 4.4 Ejecución y Análisis Iterativo

Realizamos un análisis iterativo para encontrar el núcleo del grafo de superación.

#### Iteración 1: Todas las alternativas

Primero, ejecutamos el método con las 5 alternativas.

```{r}
library(qgraph)
#Ejecutar ELECTRE I (Iteración 1) 

print("--- Ejecutando ELECTRE I: Iteración 1 (Todas las alternativas) ---")

# 1. Ejecutar ELECTRE I (Iteración 1: Todas las alternativas)
#    Usamos la función de clase
salida_electre1 <- multicriterio.metodoELECTRE_I(
    tabdecs.X = matriz_electre,
    pesos.criterios = pesos_electre,
    nivel.concordancia.minimo.alpha = alpha_concordancia,
    no.se.compensan = umbrales_discordancia
)

# 2. Mostrar el núcleo (las mejores alternativas)
print("--- ELECTRE Iteración 1: Núcleo Aproximado ---")
print(salida_electre1$nucleo_aprox)

# 3. Mostrar el grafo de dominancia
print("--- ELECTRE Iteración 1: Grafo de Dominancia ---")
qgraph::qgraph(salida_electre1$relacion.dominante, 
               labels = rownames(matriz_electre),
               edge.labels = FALSE,
               posCol = "blue",
               label.cex = 1.2,
               label.color = "black",
               vsize = 10)
```

#### Iteración 2: Filtrado del Núcleo

El núcleo de la Iteración 1 nos devuelve 4 alternativas. Repetimos el análisis solo con estas alternativas para intentar desempatar.

```{r}
library(qgraph)
# Ejecutar ELECTRE I (Iteración 2)

# 1. Identificamos las alternativas del núcleo anterior
alternativas_nucleo1 <- salida_electre1$nucleo_aprox 
alternativas_nucleo1_nombres <- names(alternativas_nucleo1)

print("--- Ejecutando ELECTRE I: Iteración 2 (solo núcleo) ---")
print("Alternativas en esta iteración:")
print(alternativas_nucleo1_nombres)

# 2. Ejecutamos ELECTRE I de nuevo, pero pasando el vector de
#    alternativas en el parámetro 'que.alternativas'
salida_electre2 <- multicriterio.metodoELECTRE_I(
    tabdecs.X = matriz_electre,
    pesos.criterios = pesos_electre,
    nivel.concordancia.minimo.alpha = alpha_concordancia,
    no.se.compensan = umbrales_discordancia,
    que.alternativas = alternativas_nucleo1_nombres # ¡Filtro clave!
)

# 3. Imprimir el núcleo final
print("--- ELECTRE Iteración 2: Núcleo Final ---")
print(salida_electre2$nucleo_aprox)

# 4. Mostrar el grafo de dominancia final
print("--- ELECTRE Iteración 2: Grafo de Dominancia Final ---")
qgraph::qgraph(salida_electre2$relacion.dominante, 
               labels = alternativas_nucleo1_nombres,
               edge.labels = FALSE,
               posCol = "blue",
               label.cex = 1.2,
               label.color = "black",
               vsize = 10)
```


### 4.5 Conclusiones del Método ELECTRE I

El método ELECTRE I se ha ejecutado **siguiendo el paso a paso** requerido.

1.  **Iteración 1:** Al ejecutar el método con las 5 alternativas, el grafo de superación mostró que la alternativa "Ciclismo" era dominada, mientras que las otras cuatro (Natacion, Running, CrossFit, Yoga) no recibían ninguna relación de dominancia. El **núcleo aproximado** resultante fue, por tanto, **[Natacion, Running, CrossFit, Yoga]**.

2.  **Iteración 2:** Para desempatar, se repite el análisis filtrando solo por las alternativas del núcleo. El grafo resultante **no muestra ninguna flecha**, lo que significa que existe una **relación de incomparabilidad** entre estas cuatro alternativas. El núcleo final sigue siendo **[Natacion, Running, CrossFit, Yoga]**.

**Conclusión:** ELECTRE I no nos da un único ganador. Concluye que **Natación, Running, CrossFit y Yoga** son las mejores opciones y son **incomparables** entre sí; ninguna es estrictamente mejor que la otra bajo los parámetros $\alpha=0.7$ y los umbrales de discordancia establecidos.


## 5. Método PROMETHEE II

El método PROMETHEE II es un enfoque de decisión multicriterio que utiliza funciones de preferencia para comparar alternativas y generar un ranking completo basado en flujos netos.

### 5.1. Definición de Parámetros y Funciones de Preferencia

Este es el paso clave de PROMETHEE en el que se deben definir las funciones de preferencia generalizadas para cada uno de los 8 subcriterios.

```{r}
# --- Cargar Funciones
source("teoriadecision_funciones_multicriterio.R")
source("teoriadecision_funciones_multicriterio_utiles.R")
source("teoriadecision_funciones_multicriterio_diagram.R")
```


```{r}
# Definir Parámetros de PROMETHEE


# 1. Matriz de Decisión: Reutilizamos la de ELECTRE


# 2. Pesos: Reutilizamos los de ELECTRE (normalizados de AHP)

pesos_promethee <- pesos_electre

# 3. Vector min/max:
vec_fminmax <- rep("max", ncol(matriz_electre))


# 4. Tabla de Funciones de Preferencia (tab.fpref)
tab_fpref_promethee <- matrix(
  c(
    3, 0.00, 0.20, 0,  # C1.1 Cardio: V-shape (p=20%)
    3, 0.00, 0.25, 0,  # C1.2 Músculo: V-shape (p=25%)
    5, 0.05, 0.25, 0,  # C1.3 Flexibilidad: Linear c/ indif (q=5%, p=25%)
    2, 0.10, 0.00, 0,  # C1.4 Impacto: U-shape (q=10%)
    3, 0.00, 0.20, 0,  # C2.1 Estrés: V-shape (p=20%)
    1, 0.00, 0.00, 0,  # C2.2 Social: Usual
    5, 0.05, 0.25, 0,  # C3.1 Coste: Linear c/ indif (q=5%, p=25%)
    1, 0.00, 0.00, 0   # C3.2 Accesibilidad: Usual
  ),
  ncol = 4, 
  byrow = TRUE
)

```

### 5.2. Ejecución y Resultados de PROMETHEE II

Ahora, ejecutamos el método PROMETHEE II. Este método generará un ranking completo de las 5 alternativas, ordenándolas por su flujo neto (Phi).

```{r}
# Ejecutar PROMETHEE
# Ejecutamos las funciones y guardamos las tablas en una variable

salida_promethee <- multicriterio.metodo.promethee_windows(
  matdecision = matriz_electre,
  tab.fpref = tab_fpref_promethee,
  pesos.criterios = pesos_promethee,
  fminmax = vec_fminmax
)


tablas_promethee <- multicriterio.metodo.promethee_windows_kableExtra(salida_promethee)

```

Tabla de Escenario (Parámetros)

A continuación, se muestra la tabla de escenario que resume los parámetros, pesos y las funciones de preferencia utilizadas.

```{r}
# Mostrar Tabla de Escenario 

tablas_promethee$tabEscenario
```


Tabla de Ranking (Resultados)

La siguiente tabla muestra el ranking final de las alternativas. El orden se basa en el flujo neto (Phi).

```{r}
# Mostrar Tabla de Ranking

tablas_promethee$tabAcciones
```

### 5.3. Conclusiones del Método PROMETHEE II

El método PROMETHEE II, a diferencia de ELECTRE I, sí nos proporciona un **ranking completo** de las alternativas, basado en el Flujo Neto (Phi). Este flujo se calcula como la diferencia entre el flujo positivo (Phi.mas, o las fortalezas) y el flujo negativo (Phi.menos, o las debilidades) de cada alternativa.

El ranking final obtenido es:

1.  **Natacion (Phi = 0.1209)**
2.  **Running (Phi = 0.0448)**
3.  **Yoga (Phi = 0.0286)**
4.  CrossFit (Phi = -0.0628)
5.  Ciclismo (Phi = -0.1315)

**Análisis de la tabla:**

* **El Ganador:** Natacion emerge como la mejor alternativa. Es la que presenta el **mejor compromiso** (el mayor Flujo Neto). No tiene el Phi.mas más alto, pero sí tiene uno de los Phi.menos más bajos (0.2326), indicando que tiene pocas debilidades significativas frente al resto.

* **Diferencia con AHP:** Es muy interesante ver que los ganadores de AHP (Yoga y CrossFit) caen al 3º y 4º puesto.
    * **Yoga** tiene el Phi.mas (fortalezas) más alto de todos (0.4183), confirmando su dominio en criterios clave. Sin embargo, también tiene el segundo Phi.menos` (debilidades) más alto (0.3897), lo que penaliza su flujo neto.
    * **CrossFit** tiene el Phi.menos más alto (0.4107), lo que significa que, aunque es muy fuerte en `Desarrollo Muscular, tiene debilidades muy marcadas en otros criterios (como Impacto o Coste) que hacen que las demás alternativas lo superen con frecuencia.

* **Consistencia:** El método es consistente con AHP y ELECTRE al identificar a Ciclismo (Phi = -0.1315) como la alternativa menos preferida.

**Conclusión:** PROMETHEE II, usando las funciones de preferencia definidas, favorece a la **Natación** por ser la alternativa más equilibrada y con menos debilidades.

---

## 6. Conclusiones Finales (Comparativa de Métodos)

En este trabajo se han aplicado tres métodos de decisión multicriterio (AHP, ELECTRE I y PROMETHEE II) para resolver el problema de la "Selección del deporte más completo para una vida saludable".

A continuación, se presenta una tabla comparativa con los rankings obtenidos por cada método:

| Rango | Método AHP | Método ELECTRE I | Método PROMETHEE II |
|:---|:---|:---|:---|
| **1º** | Yoga (24.1%) | \multirow{4}{*}{Núcleo Incomparable} | **Natacion (Phi: 0.121)** |
| **2º** | CrossFit (23.7%) | | Running (Phi: 0.045) |
| **3º** | Natación (20.2%) | | Yoga (Phi: 0.029) |
| **4º** | Running (17.3%) | | CrossFit (Phi: -0.063) |
| **5º** | Ciclismo (14.7%) | *Eliminado (Dominado)* | Ciclismo (Phi: -0.132) |


### Justificación de las Diferencias entre Métodos

El análisis de los tres métodos revela diferencias significativas que se explican por la lógica interna de cada uno:

1.  **Consistencia en la Peor Alternativa:** Los tres métodos son **unánimes** en identificar a Ciclismo como la alternativa menos preferida. AHP le da la puntuación más baja, ELECTRE I la elimina por ser dominada, y PROMETHEE II le da el flujo neto más negativo.

2.  **Diferencia en los Ganadores (AHP vs. PROMETHEE):**
    * **AHP** (un método de agregación total) da como ganador al **Yoga (24.1%)**. Esto se debe a que la estructura jerárquica y la multiplicación de pesos le dan una enorme importancia a su dominio en Reducción de Estrés (que aporta un 10.9% del total).
    * **PROMETHEE II** (un método de flujos netos) da como ganador a la **Natación (Phi: 0.121)**. Este método favorece a la alternativa más equilibrada; aunque el Yoga tiene muchas fortalezas (Phi.mas de 0.4183), también tiene muchas debilidades (Phi.menos de 0.3897), lo que resulta en un flujo neto bajo. La Natación gana por tener el mejor balance entre fortalezas y debilidades (un Phi.menos muy bajo de 0.2326).

3.  **El Caso de ELECTRE I (Incomparabilidad):**
    * AHP y PROMETHEE **fuerzan un ranking completo**, obligando a comparar todas las alternativas.
    * **ELECTRE I** (un método de superación) es el único que respeta la **incomparabilidad**. Concluye que Yoga, CrossFit, Natación y Running son incomparables. Esto se debe a los fuertes conflictos entre criterios (ej. Desarrollo Muscular del CrossFit vs. Reducción de Estrés del Yoga). Al no poder resolver estos conflictos con los parámetros dados, el método los agrupa en un "núcleo" de buenas soluciones.

### Conclusión Final

No existe un "mejor método", sino que cada uno aporta una visión diferente:
* Si el decisor busca la **excelencia en un criterio clave** (Salud Mental), **AHP** le recomienda el **Yoga**.
* Si el decisor busca la **alternativa más equilibrada y con menos debilidades**, **PROMETHEE II** le recomienda la **Natación**.
* Si el decisor no está dispuesto a aceptar compensaciones entre criterios muy distintos, **ELECTRE I** le presenta un conjunto de **4 finalistas** igualmente válidos.








